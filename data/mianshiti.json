[
  {
    "name": "第一部分：ASP.NET",
    "data": [
      {
        "title": "1、类和结构的区别",
        "text": "类是引用类型，结构是值类型\n类可以继承，也可以实现接口；结构不能继承，但可以实现接口\n类可以有显示的无参数构造函数；结构不能包含显示的无参数构造函数\n结构中不能有实例字段初始值设定；类没有任何限制"
      },
      {
        "title": "2、访问修饰符",
        "text": "public：公有的任何位置都可以访问\nprivate：私有的只有类本身可以访问\nprotected：受保护的只有类的自身和派生类可以访问\ninternal：内部的同一个程序集的任何位置都能访问\nprotected internal：内部受保护的同一个程序集或不同程序集的派生类可以访问"
      },
      {
        "title": "3、面向对象的三大特征",
        "text": "继承：子类继承父类\n封装：对外提供一个访问的接口，对内私有化\n多态：重写\nOverriding，重载\nOverloading"
      },
      {
        "title": "4、抽象类和接口的区别",
        "text": "接口：interface\n抽象类：\nabstract\n声明方法的存在而不去实现它的类被叫做抽像类\n相同点：都不能被实例化，都可以包含多个抽象成员\n不同点：抽象类可以包含已经实现的抽象方法，可以继承类，接口不能包含已经实现的抽象方法，无法继承类"
      },
      {
        "title": "5、接口可以包含哪些成员",
        "text": "方法，属性，事件，索引器"
      },
      {
        "title": "6、什么是装箱和拆箱？",
        "text": "装箱：将值类型转换成引用类型\n拆箱：将引用类型转换成值类型"
      },
      {
        "title": "7、哪些类型是值，引用类型？",
        "text": "值类型：结构，枚举\n引用类型：类，接口，委托，数组，字符串"
      },
      {
        "title": "8、值类型和引用类型的区别？",
        "text": "值类型的数据存储在线程栈上，变量本身存储数据\n引用类型的数据存储在托管堆上，变量存储引用地址"
      },
      {
        "title": "9、重写和重载？",
        "text": "重写: Overrides\n子类对父类中的虚成员或抽象成员进行重新实现\n重载：Overloading\n同名方法，参数不同"
      },
      {
        "title": "10、用户控件",
        "text": "后缀：.ascx\n特点：方便，可以根据需求自定义控件"
      },
      {
        "title": "11、JQ选择器",
        "text": "类选择器\nID选择器\n标签选择器"
      },
      {
        "title": "12、向服务器发送请求方式？",
        "text": "get:向服务器请求数据\npost:向服务器提交数据"
      },
      {
        "title": "13、const static readonly",
        "text": "const:常量声明的同时必须赋值，无法修改值\nstatic：静态的，表示在当前类是可以全局访问的\nreadonly：只读声明时可以赋值也可以不赋值，值只能在构造函数中修改"
      },
      {
        "title": "14、String StringBilider分别是什么意思？有什么区别",
        "text": "string:\n字符串常量进行运算时会生成副本\nStringBilider\n字符串变量进行运算时不会生成副本"
      },
      {
        "title": "15、ADO.NET之中有哪些对象？",
        "text": "SqlConnection：连接对象，用于执行与数据库的连接。\nSqlCommand：命令对象，用于对数据库执行SQL语句。\nSqlDataAdapter：适配器对象，用于填充数据集和更新数据库。\nSqlParameter：参数对象，用于执行参数化SQL语句。\nSqlDataReader：读取器对象，用于从数据库中快速逐行读取数据。\nSqlTransaction：事务对象，用于执行数据库事务。"
      },
      {
        "title": "16、Using关键字是什么意思？",
        "text": "导入或引用命名空间\n给类型取别名\n释放资源"
      },
      {
        "title": "17、请描述is和as关键字分别是什么意思？",
        "text": "is:检查对象是否与给定的类型是否相兼容\nas:\n用于对引用类型的变量进行转换"
      },
      {
        "title": "18、Asp.NET之中页面传值方式有哪些？",
        "text": "QuerString\n优点：简单便捷\n缺点：安全性差，长度大小有限制\nSession\n服务器传值\n优点：当前所有会话的所有页面可以使用，能够传递任何对象\n缺点：可能会丢失\n解决办法：存储在进程或数据库中\nCookie\n客户端传值\n优点：读取该Cookie的所有页面都可以使用\n缺点：只能存储文本信息，大小不能超过4KB\nApplication\n优点：整个应用程序都可以使用，能够传递任何对象\n缺点：可能会产生并发问题\nServer.Transfer\n优点：URL不会重定向\n缺点：资源消耗较大\n"
      },
      {
        "title": "19、ref 和 out 区别",
        "text": "ref\n在传入方法之前必须赋值,可以直接在方法内部调用\nout\n在方法返回之前必须赋值，不能直接在方法调用"
      },
      {
        "title": "20、string=null 的区别",
        "text": "string=\"\"\n为字符分配了内存空间\nstring=null\n没有分配内存空间"
      },
      {
        "title": "21、new 的用法",
        "text": "用于创建对象和调用构造函数\n用于创建匿名类型的实例\n可以显示隐藏从父类继承的成员"
      },
      {
        "title": "22、& 和 &&的区别",
        "text": "&\n按位与表示对两个整型进行按位与计算\n&&\n逻辑与对两个布尔类型进行逻辑与操作，两边都为true时返回true\n|\n按位或表示对两个整型进行按位或计算\n||\n逻辑或对两个布尔类型进行逻辑与操作，其中一边为true时返回true"
      },
      {
        "title": "23、什么是 GC ？ 为什么用到GC？",
        "text": "GC：垃圾收集器\n垃圾收集器是一种自动进行内存管理的机制，使得程序员不需要手动去分配内存和释放内存\n提高了程序的安全性，稳定性，及开发效率"
      },
      {
        "title": "24、什么是委托？事件和委托的关系？",
        "text": "委托：delegate\n将函数当作参数传入另一个函数中\nevent事件关键字\n事件也是一种委托"
      },
      {
        "title": "25、ADO.NET中访问数据库的基本步骤是什么？",
        "text": "创建数据库连接对象：sqlconnection con=new sqlconnection(\"server=.;database=Attendance;uid=sa;pwd=sa;\");\n打开连接:con.Open();\nstring sql=\"insert into UserInfo(U_ID,U_Name) values('1000','admin')\";\n创建命令对象：sqlcommand cmd=new sqlcommand(sql,con);\n执行sql语句：return rows=cmd.ExecuteNonQuery()>0；\n关闭连接：con.Close();"
      },
      {
        "title": "26、身份验证",
        "text": "Windows验证：ASP.NET会结合Internet信息服务（IIS），为每个用户开启Windows账户，通过Windows账户验证用户身份。\nForms验证：ASP.NET通过Web表单，为每个用户创建一个用cookie保存的身份验证票据，通过该票据验证用户身份。\nPassport验证：由 Microsoft 提供的集中身份验证服务，通过将每个用户的信息提交给Passport 登录服务网站进行用户身份的验证。\nNone验证：自定义身份验证方式。"
      },
      {
        "title": "27、Server.Transfer 与 Response.Redirect 有什么区别？",
        "text": "Server.Transfer:服务器端重定向，URL不变\nResponse.Redirect:客户端重定向，重定向URL"
      },
      {
        "title": "28、Code-Behind技术",
        "text": "代码隐藏技术"
      },
      {
        "title": "29、ASP.NET 中调用 Web Service的方法有哪些？",
        "text": "通过HTTP-GET请求调用\n通过HTTP-POST请求调用\n通过SOAP请求调用"
      },
      {
        "title": "30、？和？？",
        "text": "？：三元运算符\n返回符合条件的值\n？？：合并运算符\n左边不为NULL\n时\n返回\n左边的值，反之返回右边的值"
      },
      {
        "title": "31、DateSet 和 DateReader的区别？",
        "text": "DateSet：数据表集合，一次性读取数据库\nDateReader：数据读取器，逐行读取数据"
      },
      {
        "title": "32、无状态编程",
        "text": "客户端向服务端发送请求，服务端不会主动记录任何请求信息，请求结束后释放资源，这种请求和响应的过程称为无状态编程"
      },
      {
        "title": "33、Web Service有哪些优点？",
        "text": "Web Service是基于XML的，与具体语言和平台无关，故可以实现跨平台，跨语言通信\nWeb Service是采用SOAP\n协议进行通信的，该协议基于HTTP协议，故可以实现跨防火墙通信\nWeb Service可以很容易实现分布式的应用程序"
      },
      {
        "title": "34、ASP.NET 缓存有几种实现方式？",
        "text": "OutputCache:页面输出缓存，将页面全部进行缓存\nRegister:页面局部缓存，缓存用户控件\n数据缓存：Cache 使用Cache类缓存\n客户端缓存：使用HttpCachePolicy类进行客户端缓存"
      },
      {
        "title": "35、ViewState",
        "text": "ViewState：视图状态，当前页面传值"
      },
      {
        "title": "36、ASP.NET中常见文件的后缀名有哪些",
        "text": "aspx：页面\nascx：用户控件\nasmx：Web Service\nashx：一般处理程序\nasax：Global.asax，全局应用程序配置"
      },
      {
        "title": "37、实现Ajax 请求的常用方法有哪些？ 有什么区别？",
        "text": "$.get\n通过get方式发送请求\n$.post 通过post方式发送请求\n$.ajax可以使用指定的方式发送请求\n$.getJSON()"
      },
      {
        "title": "38、MVC的含义及作用",
        "text": "M:\nModel,模型，用于数据的访问\nV：View,视图，用于呈现页面\nC：Controller，控制器，用于处理请求逻辑，访问默写数据\n好处：各施其职，互不干涉，有利于开发中的分工，有利于组件的重用"
      },
      {
        "title": "39、MVC请求的处理过程",
        "text": "客户端发送请求，请求到达服务器后，进入路由器验证，验证通过后，将请求交给控制器中的动作处理，在动作中可能会访问模型中的数据，处理相应的业务逻辑，然后根据请求的内容返回相应的视图呈现给客户端"
      },
      {
        "title": "40、什么叫应用程序域？",
        "text": "应用程序域可以理解为一种轻量级进程。起到安全的作用。占用资源小"
      },
      {
        "title": "41、CTS、CLS、CLR分别作何解释？",
        "text": "CTS：通用语言系统。CLS：通用语言规范。CLR：公共语言运行库。"
      },
      {
        "title": "42、什么是受管制的代码？",
        "text": "unsafe：非托管代码。不经过CLR运行。"
      },
      {
        "title": "43、什么是强类型系统？",
        "text": "类型识别系统。"
      },
      {
        "title": "44、在.net中，配件的意思是？",
        "text": "程序集。（中间语言，源数据，资源，装配清单）"
      },
      {
        "title": "45、14.	ASP.NET中的六大对象有哪些",
        "text": "Request、(请求对象)\nResponse、(响应对象)\nServer、(服务器对象)\nSession、(会话对象)\nCookie、\nApplication(应用程序对象)"
      },
      {
        "title": "46、",
        "text": ""
      },
      {
        "title": "47、foreach遍历访问的对象需要实现",
        "text": "能用foreach遍历访问的对象需要实现 IEnumerable 接口或声明 GetEnumerator 方法的类型"
      },
      {
        "title": "48、进程和线程的区别？",
        "text": "进程是系统进行资源分配和调度的单位；线程是CPU调度和分派的单位，一个进程可以有多个线程，这些线程共享这个进程的资源"
      },
      {
        "title": "49、堆和栈的区别？",
        "text": "栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义；堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小"
      },
      {
        "title": "50、软件开发过程一般有几个阶段？每个阶段的作用？",
        "text": "需求分析，架构设计，代码编写，QA，部署"
      },
      {
        "title": "51、什么叫做SQL注入，如何防止？请举例说明",
        "text": "利用sql语言漏洞获得合法身份登陆系统\n解决办法：1.PreparedStatement\n2.使用正则表达式过滤传入的参数\n3.字符串过滤\n4.jsp中调用该函数检查是否包函非法字符"
      },
      {
        "title": "52、什么是虚函数？什么是抽像函数？",
        "text": "虚函数：可由子类继承并重写的函数。抽像函数：规定其非虚子类必须实现的函数，必须被重写。"
      },
      {
        "title": "53、什么是XML？",
        "text": "XML即可扩展标记语言"
      },
      {
        "title": "54、XML 与 HTML 的主要区别",
        "text": "1.XML是区分大小写字母的，HTML不区分。\n2.在HTML中，如果上下文清楚地显示出段落或者列表键在何处结尾，那么你可以省略</p>或者</li>之类的结束标记。在XML中，绝对不能省略掉结束标记。\n3.\n在XML中，拥有单个标记而没有匹配的结束标记的元素必须用一个/\n字符作为结尾。这样分析器就知道不用查找结束标记了。\n4.在XML中，属性值必须分装在引号中。在HTML中，引号是可用可不用的。\n5.在HTML中，可以拥有不带值的属性名。在XML中，所有的属性都必须带有相应的值。"
      },
      {
        "title": "55、如何处理几十万条并发数据",
        "text": "用存储过程或事务。取得最大标识的时候同时更新..注意主键不是自增量方式这种方法并发的时候是不会有重复主键的..取得最大标识要有一个存储过程来获取."
      },
      {
        "title": "56、成员变量和成员函数前加static的作用？",
        "text": "它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。分别用来反映类的状态。比如类成员变量可以用来统计类实例的数量，类成员函数负责这种统计的动作"
      },
      {
        "title": "57、谈谈final, finally, finalize的区别",
        "text": "final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载\nfinally—再异常处理时提供finally\n块来执行任何清除操作。如果抛出一个异常，那么相匹配的catch\n子句就会执行，然后控制就会进入finally\n块（如果有的话）。\nfinalize—方法名。Java\n技术允许使用finalize()\n方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object\n类中定义的，因此所有的类都继承了它。子类覆盖finalize()\n方法以整理系统资源或者执行其他清理工作。finalize()\n方法是在垃圾收集器删除对象之前对这个对象调用的\n　　"
      },
      {
        "title": "58、sleep() 和 wait()",
        "text": "sleep()方法是使线程停止一段时间的方法\nwait()是线程交互时，如果线程对一个同步对象x\n发出一个wait()调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到"
      },
      {
        "title": "59、Set里的元素是不能重复的",
        "text": "Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。\nequals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值"
      },
      {
        "title": "60、swtich",
        "text": "switch（expr1）中，expr1是一个整数表达式。因此传递给switch 和case 语句的参数应该是int、short、char 或者byte。long,string 都不能作用于swtich"
      },
      {
        "title": "61、构造器Constructor",
        "text": "构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。"
      },
      {
        "title": "62、启动一个线程",
        "text": "启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程"
      }
    ]
  },
  {
    "name": "第二部分：SQL Server",
    "data": [
      {
        "title": "1、排序",
        "text": "Row_Number 排序"
      },
      {
        "title": "2、判断",
        "text": "case_when  表示判断"
      },
      {
        "title": "3、取出表中第31到40条记录",
        "text": "方法一：\nselect\ntop\n10\n*\nfrom\nA\nwhere\nid\nnot\nin\n(select\ntop\n330\nid\nfrom\nA\norder\nby\nid)\norder\nby\nid\n方法二：select\ntop\n10\n*\nfrom\nA\nwhere\nid>(select\nmax(id)\nfrom\n(select\ntop\n30\nid\nfrom\nA\norder\nby\nid)\nt)\n方法三：select\n*\nfrom\n(select\n*\nrow_number()\nover\n(order\nby\nid)\nRow_No\nfrom\nA)\nt\nwhere\nRow_No\nbetween\n31\nand\n40\n"
      },
      {
        "title": "4、SQL中三种表连接的方式",
        "text": "inner join : 内联查询，查询出满足on条件的两个表的公共交集\nleft join ： 左外联查询，以左边的表为基准与右边的进行关联，连接查询出满足on条件的结果，左表数据完全保留，右边无法满足条件的数据用null与左表数据补齐\nright join ：右外联查询，以右边的表为基准与左边的进行关联，连接查询出满足on条件的结果，右表数据完全保留，左边无法满足条件的数据用null与右表数据补齐"
      },
      {
        "title": "5、存储过程和函数的区别",
        "text": "函数可以嵌入在\nsql语句中使用，存储过程需要通过exec调用\n函数限制较多，存储过程限制相对较少\n存储过程用于实现复杂的业务逻辑，函数实现功能针对性较强的业务\n存储过程可以返回多个输出参数或结果集，函数只能返回一个输出参数或结果表对象\n"
      },
      {
        "title": "6、数据库索引是什么？有什么用？",
        "text": "索引：是数据库表中一列或多列的值进行排序的一种结构\n作用：用于加快从表中查询数据的速度"
      },
      {
        "title": "7、数据库索引的分类及区别？",
        "text": "聚集索引：表示索引的逻辑顺序与磁盘上行的物理存储顺序相同\n非聚集索引：表示索引的逻辑顺序与磁盘上行的物理存储顺序不同"
      },
      {
        "title": "8、什么是事务？有哪些特性？",
        "text": "事务：作为单个逻辑工作单元执行的一系列操作\n特性：原子性（Atomicity） 不可再分，要么完全地执行，要么完全地不执行\n一致性（Consistency）：事务从开始到结束，所有数据都保持一直状态\n隔离性（Isolation）：事务的执行时互不干扰的\n持久性（Durability）:事务完成后，对数据库所做的更改会持久的保存在数据库中，不会被回滚"
      },
      {
        "title": "9、事务的好处",
        "text": "可以保证数据的完整性和一致性"
      },
      {
        "title": "10、触发器",
        "text": "DML 触发器：在数据变更时触发\nDML 触发器又分为：\nafter触发器（之后触发）：在触发 insert、update 或是delect 动作之后执行，只能定义在表上\ninstead of 触发器（之前触发）：触发器代替触发动作进行激发，并在处理约束之前激发\nDDL 触发器：在修改数据库级别或实例级别对象时触发"
      },
      {
        "title": "11、delete和truncate的区别？",
        "text": "delete 可以带 where 条件 ，用于删除指定条件的数据，truncate 和 table 组合使用，truncate不能带 where条件\ntruncate 在删除 表中全部数据时会重置自动增长列，delete 不会"
      },
      {
        "title": "12、union 和 union all 的区别？",
        "text": "union 和 union all 都可以用作两张表数据的合并\nunion :在合并的同时去除重复的数据\nunion all：直接合并，不做处理"
      },
      {
        "title": "13、查询成绩在前三的学生",
        "text": "select * from （select * dense_rank() over (order by 学生成绩 desc) NO  from 学生成绩表） t where NO<=3\nselect * from （select * rank() over (order by 学生成绩 desc) NO  from 学生成绩表） t where NO<=3\nselect * from （select * row_number() over (order by 学生成绩 desc) NO  from 学生成绩表） t where NO<=3"
      },
      {
        "title": "14、如何得到自增长自段的当前值？",
        "text": "select @@identity"
      },
      {
        "title": "15、游标的作用？如何知道游标到了最后？",
        "text": "作用：逐行读取结果集中的数据\n当全局变量 @@fetch_status的值不等于0时，表示游标已经到了最后"
      },
      {
        "title": "16、什么是内存泄漏？",
        "text": "内存泄漏指的是堆内存的泄漏"
      },
      {
        "title": "17、什么叫视图？",
        "text": "视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。"
      },
      {
        "title": "18、维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？",
        "text": "我是这样做的，尽可能使用约束，如check,主键，外键，非空字段等来约束，这样做效率最高，也最方便。其次是使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保证数据的完整新和一致性。最后考虑的是自写业务逻辑，但这样做麻烦，编程复杂，效率低下"
      },
      {
        "title": "19、以ID为条件，将A表中B列插入B表B列",
        "text": "update B set B.name=A.name from A where A.id=B.id"
      },
      {
        "title": "20、给出所有购入商品为两种或两种以上的购物人记录",
        "text": "购物人 商品名 数量\nA&emsp;&emsp;甲&emsp;&emsp;2\nB&emsp;&emsp;乙&emsp;&emsp;4\nC&emsp;&emsp;丙&emsp;&emsp;1\nA&emsp;&emsp;甲&emsp;&emsp;2\nB&emsp;&emsp;乙&emsp;&emsp;5\nselect 购物人 from 购物信息 group by 购物人 having COUNT(商品名)>=2"
      }
    ]
  },
  {
    "name": "第三部分：算法",
    "data": [
      {
        "title": "1、递归计算1+2+。。+100",
        "text": "<pre>class Profram\n{\n    static void Main(string[] args)\n    {\n        int total = Sum(100);\n        Console.WriteLine(total);\n\n    }\n\n    static int Sum(int x)\n    {\n        if (x <= 1)\n        {\n            return x;\n        }\n        else\n        {\n            return x + Sum(x - 1);\n        }\n    }\n}</pre>"
      },
      {
        "title": "2、冒泡排序(从大到小)",
        "text": "<pre>class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = { 6, 2, 4, 1, 5, 9 };\n            bubbleSort4(x);\n            foreach (var item in x)\n            {\n                Console.WriteLine(item);\n            }\n        }\n        //写法一\n        static void bubbleSort1(int[] arr)\n        {\n            for (int i = 0; i < arr.Length; i++)\n            {\n                for (int j = i; j < arr.Length; j++)\n                {\n                    if (arr[i] > arr[j])\n                    {\n                        int temp = arr[i];\n                        arr[i] = arr[j];\n                        arr[j] = temp;\n                    }\n                }\n            }\n        }\n        //写法二\n        static void bubbleSort2(int[] arr)\n        {\n            for (int i = 0; i < arr.Length; ++i)\n            {\n                for (int j = i + 1; j < arr.Length; j++)\n                {\n                    if (arr[i] > arr[j])\n                    {\n                        int temp = arr[i];\n                        arr[i] = arr[j];\n                        arr[j] = temp;\n                    }\n                }\n            }\n        }\n        //写法三\n        static void bubbleSort3(int[] arr)\n        {\n            for (int i = 0; i < arr.Length; ++i)\n            {\n                for (int j = arr.Length - 1; j > i; j--)\n                {\n                    if (arr[j] < arr[j - 1])\n                    {\n                        int temp = arr[j];\n                        arr[j] = arr[j - 1];\n                        arr[j - 1] = temp;\n                    }\n                }\n            }\n        }\n        //写法四\n        static void bubbleSort4(int[] arr)\n        {\n            for (int i = 0; i < arr.Length-1; i++)\n            {\n                for (int j = 0; j < arr.Length - i-1; j++)\n                {\n                    if (arr[j] > arr[j + 1])\n                    {\n                        int temp = arr[j];\n                        arr[j] = arr[j + 1];\n                        arr[j + 1] = temp;\n                    }\n                }\n            }\n        }\n    }</pre>"
      },
      {
        "title": "3、统计每一种字符的出现次数",
        "text": "<pre>public static void CountChar(string s)\n    {\n        Dictionary<char, int> dic = new Dictionary<char, int>();\n\n        foreach (char c in s)\n        {\n            if (dic.ContainsKey(c))\n            {\n                dic[c]++;\n            }\n            else\n            {\n                dic.Add(c, 1);\n            }\n        }\n\n        foreach (KeyValuePair<char, int> p in dic)\n        {\n            Console.WriteLine(\"字符：{0}，出现次数：{1}\", p.Key.ToString(), p.Value.ToString());\n        }\n    }</pre>"
      },
      {
        "title": "4、字符串转换成整数",
        "text": "<pre>public static bool TryParse(String s, out int num)\n    {\n        if (string.IsNullOrEmpty(s))\n        {\n            num = 0;\n            return false;\n        }\n\n        int result = 0;\n        bool minus = s[0] == '-' ? true : false;\n        if (minus && s.Lenght == 1)\n        {\n            num = 0;\n            return false;\n        }\n\n        for (int i = minus ? 1 : 0; i < s.Lenght; i++)\n        {\n            if (s[i] >= '0' && s[i] <= '9')\n            {\n                result = (s[i] - 48) + result * 10;\n            }\n            else\n            {\n                num = 0;\n                return false;\n            }\n        }\n\n        num = minus ? -result : result;\n        return true;\n    }</pre>"
      },
      {
        "title": "5、斐波那契数列--1 1 2 3 4...",
        "text": "<pre>public class MainClass\n    {\n        public static void Main()\n        {\n            Console.WriteLine(Foo(30));\n        }\n        public static int Foo(int i)\n        {\n            if (i <= 0)\n                return 0;\n            else if (i > 0 && i <= 2)\n                return 1;\n            else return Foo(i - 1) + Foo(i - 2);\n        }\n    }</pre>"
      },
      {
        "title": "6、产生一个int数组，长度为100，并向其中随机插入1-100，并且不能重复",
        "text": "<pre>public static void Main()\n        {\n            int[] intArr = new int[100];\n            ArrayList myList = new ArrayList();\n            Random rnd = new Random();\n            while (myList.Count < 100)\n            {\n                int num = rnd.Next(1, 101);\n                if (!myList.Contains(num))\n                    myList.Add(num);\n            }\n            for (int i = 0; i < 100; i++)\n            {\n                intArr[i] = (int)myList[i];\n            }\n        }</pre>"
      }
    ]
  },
  {
    "name": "第四部分：代码",
    "data": [
      {
        "title": "1、复选框 全选 反选",
        "text": "<pre>function selectAll() {\n    //$(\":checkbox:gt(0)\").prop(\"checked\", $(\":checkbox:eq(0)\")[0].checked);\n    $(\":checkbox:gt(0)\").each(function () {\n        //this.checked = $(\":checkbox:eq(0)\")[0].checked\n        $(this)[0].checked = $(\":checkbox:eq(0)\")[0].checked\n    })\n}</pre>"
      },
      {
        "title": "2、表格隔行变色",
        "text": "<pre>$(document).ready(function () {\n    $(\"#table tr:even\").css(\"background-color\", \"Orange\");\n    $(\"#table tr:odd\").css(\"background-color\", \"Pink\");\n})</pre>"
      },
      {
        "title": "3、表格中鼠标移动的光棒效果",
        "text": "<pre>$(document).ready(function () {\n        $(\"#table tr\").hover(function () {\n            $(this).css(\"background-color\", \"#aaee22\");\n        }, function () {\n            $(this).css(\"background-color\", \"#ffffff\");\n        });\n    })</pre>"
      },
      {
        "title": "4、请编程遍历页面上所有TextBox控件并给它赋值为string.Empty",
        "text": "<pre>foreach (System.Windows.Forms.Control control in this.Controls)\n{\n    if (control is System.Windows.Forms.TextBox)\n    {\n        System.Windows.Forms.TextBox tb = (System.Windows.Forms.TextBox)control;\n        tb.Text = String.Empty;\n    }\n}</pre>"
      }
    ]
  }
]
